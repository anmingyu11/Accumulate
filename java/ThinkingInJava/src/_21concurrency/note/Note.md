
#### 后台进程
任何一个由后台线程创建的线程，都将自动设置成后台线程
后台进程不执行finally语句块里面的
一旦main退出，JVM就会立即关闭所有的后台进程。
非后台的Executor通常是一种更好的方式，因为Executor控制所有任务可以被同时关闭。

#### 加入一个线程
t.join()
在当前线程中等待t线程的完成后再执行

#### 线程组
jdk的软件架构师说：“最好把线程组看成是一次不成功的尝试，你只要忽略它就好了。”


#### 异常处理器
Thread.setDefaultUncaughtExceptionHandler()
省着一个个的set了.

#### 共享资源竞争
并发程序的一个问题，如果失败的概率非常低，那么即使存在缺陷，它们也可能看起来是正确的。
在java中，递增不是原子性操作
使用线程时的一个基本问题，你永远不知道线程在何时运行。
如过并发的问题产生，调用yield是一种促使其发生的有效方式。

#### Lock
Lock惯用法 lock在外面 try finally unlock()在finally里面。

synchronized代码量更少，错误可能性降低，通常只有解决特殊问题时，才使用显式的Lock对象。例如用synchronized关键字不能尝试着获取锁且最终获取锁会失败，或者尝试着获取锁一段时间，然后放弃它。

显式的Lock对象在加锁和释放锁方面，相对于内建的synchronized锁来说，还赋予了你更细力度的控制力。这对于实现专有同步结构是很有用的。

#### 原子性与易变性
一个常不正确的知识是“原子操作不需要进行同步控制”。**原子操作是不能被线程调度机制中断的操作;一旦操作开始，那么它一定可以在可能发生的“上下文切换”之前（切换到其他线程执行）执行完毕。**

> Goetz测试：如果你可以编写用于现代微处理器的高性能JVM,那么就有资格去考虑是否可以避免同步。

JVM可以将64位long double的读取和写入当做两个分离的32位操作来执行，这就产生了一个读取和写入操作中间发生的上下文切换，从而导致不同的任务可以看到不正确结果的可能性。

尝试着移除同步通常是一种表示不成熟优化的信号。

volatile关键字还确保了应用中的可视性。

如果你将一个域定义为volatile的，那么它就会告诉编译器不要进行任何移除读取和写入操作的优化。

如果多个任务在同时访问某个域，那么这个域就应该是volatile的，否则，这个域就应该只能经由同步来访问。
同步也会导致向主存中刷新，因此如果一个域完全由synchronized方法或语句块来防护，那就不必将其设置为是volatile的。

原子性的典型案例AtomicTest

#### 宁愿使用同步控制块而不是使用整个方法进行同步的典型原因：
使得其他线程能更多地访问。

#### 线程本地存储。

#### 线程状态
page 737

新建，就绪，阻塞，死亡

#### 线程为什么会进入阻塞状态
1. sleep
2. wait notify notifyAll
3. 等待某个输入输出完成
4. 任务师徒在某个对象上调用其同步控制方法，但是对象锁不可用，因为另一个任务已经获取了这个锁

#### 中断
在run()方法中间打断，更像是抛出的异常，因此在Java线程中的这种类型的异常中断中用到了异常。为了在以这种方式终止任务时，返回众所周知的良好状态，你必须仔细考虑代码的执行路径，并仔细编写catch字句以正确清楚所有事物。

interrupt()方法
你能够中断sleep()调用(任何要求抛出InterruptedException的调用).
但是，你不能中断正在试图获取synchronized锁或者试图执行I/O操作的线程。这有点令人烦恼，特别是在创建执行I/O的任务时，因为这意味着I/O具有锁住你的多线程程序的潜在可能。


关闭底层资源以释放锁.

只要一个任务以不可中断的方式被阻塞，那么都有潜在的会锁住程序的可能。
